import {GeneratedAsset,Roteiro} from './types';import {logger} from './services/logger';function writeString(view:DataView,offset:number,string:string){for(let i=0;i<string.length;i++){view.setUint8(offset+i,string.charCodeAt(i));}}export function decode(base64:string):Uint8Array{const binaryString=atob(base64);const len=binaryString.length;let bytes=new Uint8Array(len);for(let i=0;i<len;i++){bytes[i]=binaryString.charCodeAt(i);}return bytes;}export function encode(bytes:Uint8Array):string{let binary='';const len=bytes.byteLength;for(let i=0;i<len;i++){binary+=String.fromCharCode(bytes[i]);}return btoa(binary);}export function pcmToWav(pcmData:Uint8Array,sampleRate:number,numChannels:number,bitsPerSample:number):Uint8Array{const bytesPerSample=bitsPerSample/8;const blockAlign=numChannels*bytesPerSample;const byteRate=sampleRate*blockAlign;const subChunk2Size=pcmData.length;const chunkSize=36+subChunk2Size;const buffer=new ArrayBuffer(44+subChunk2Size);const view=new DataView(buffer);writeString(view,0,'RIFF');view.setUint32(4,chunkSize,true);writeString(view,8,'WAVE');writeString(view,12,'fmt ');view.setUint32(16,16,true);view.setUint16(20,1,true);view.setUint16(22,numChannels,true);view.setUint32(24,sampleRate,true);view.setUint32(28,byteRate,true);view.setUint16(32,blockAlign,true);view.setUint16(34,bitsPerSample,true);writeString(view,36,'data');view.setUint32(40,subChunk2Size,true);for(let i=0;i<pcmData.length;i++){view.setUint8(44+i,pcmData[i]);}return new Uint8Array(buffer);}async function decodeAudioData(data:Uint8Array,ctx:AudioContext,sampleRate:number,numChannels:number,):Promise<AudioBuffer>{const dataInt16=new Int16Array(data.buffer);const frameCount=dataInt16.length/numChannels;const buffer=ctx.createBuffer(numChannels,frameCount,sampleRate);for(let channel=0;channel<numChannels;channel++){const channelData=buffer.getChannelData(channel);for(let i=0;i<frameCount;i++){channelData[i]=dataInt16[i*numChannels+channel]/32768.0;}}return buffer;}export async function getAudioDuration(base64OrBlobUrl:string):Promise<number>{return new Promise(async(resolve)=>{const audioContext=new (window.AudioContext||window.webkitAudioContext)({sampleRate:24000});try{let audioBytes:Uint8Array;if(base64OrBlobUrl.startsWith('blob:')){const response=await fetch(base64OrBlobUrl);const buffer=await response.arrayBuffer();audioBytes=new Uint8Array(buffer);}else{audioBytes=decode(base64OrBlobUrl);}decodeAudioData(audioBytes,audioContext,24000,1).then(buffer=>{if(buffer.duration===Infinity||isNaN(buffer.duration)){logger.warn("Audio duration is Infinity or NaN after decoding, defaulting to 5s.", {audioDuration:buffer.duration});resolve(5000);}else{resolve(buffer.duration*1000);}}).catch(e=>{logger.error("Error decoding audio data for duration calculation, defaulting to 5s.",e);resolve(5000);}).finally(()=>{if(audioContext.state!=='closed'){audioContext.close();}});;}catch(e){logger.error("Error preparing audio data for decoding, defaulting to 5s.",e);if(audioContext.state!=='closed'){audioContext.close();}resolve(5000);}});}function formatTimeSRT(ms:number):string{const date=new Date(0);date.setMilliseconds(ms);const hours=date.getUTCHours().toString().padStart(2,'0');const minutes=date.getUTCMinutes().toString().padStart(2,'0');const seconds=date.getUTCSeconds().toString().padStart(2,'0');const milliseconds=date.getUTCMilliseconds().toString().padStart(3,'0');return `${hours}:${minutes}:${seconds},${milliseconds}`;}export async function generateSRT(assets:GeneratedAsset[],roteiroText:{[key:string]:string}):Promise<string>{let srtContent="";let currentTimeMs=0;let counter=1;const blockOrder=['hook','leitura','reflexao','aplicacao','oracao'];logger.info("Starting SRT generation...");for(const blockId of blockOrder){const audioAsset=assets.find(a=>a.type==='audio'&&a.block_id===blockId);if(audioAsset){const duration=await getAudioDuration(audioAsset.data_b64);const startTime=currentTimeMs;const endTime=currentTimeMs+duration;const text=roteiroText[blockId]||"";const cleanText=text.replace(/[\r\n]+/g,' ').trim();srtContent+=`${counter}\n`;srtContent+=`${formatTimeSRT(startTime)} --> ${formatTimeSRT(endTime)}\n`;srtContent+=`${cleanText}\n\n`;currentTimeMs=endTime;counter++;logger.info(`SRT block generated for ${blockId}: ${formatTimeSRT(startTime)} --> ${formatTimeSRT(endTime)}`);}else{logger.warn(`No audio asset found for blockId: ${blockId}, skipping SRT generation for this block.`);}}logger.info("SRT generation complete.");return btoa(unescape(encodeURIComponent(srtContent)));}export function getBlockName(index:number):string{const names=["hook","leitura","reflexao","aplicacao","oracao"];return names[index];}export function mapRoteiroToTextMap(roteiro:Roteiro):{[key:string]:string}{return{'hook':roteiro.hook?.text||'','leitura':roteiro.leitura?.text||'','reflexao':roteiro.reflexao?.text||'','aplicacao':roteiro.aplicacao?.text||'','oracao':roteiro.oracao?.text||''};}
export function base64ToBlob(base64: string, mimeType: string): Blob {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}
export async function blobUrlToBase64(url: string): Promise<string> {
  const response = await fetch(url);
  const blob = await response.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const res = reader.result as string;
      resolve(res.includes(',') ? res.split(',')[1] : res);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}